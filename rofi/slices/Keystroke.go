// This code is generated by https://github.com/jtyers/slice
// DO NOT EDIT!

// nfn: NewKeystrokeSlice

package slices


import (
  . "github.com/jtyers/go-rofi/rofi/keystroke"
)

type chainKeystroke struct {
  isPtr bool
	value []Keystroke
}

func NewKeystrokeSlice(slice []Keystroke) *chainKeystroke {
	return &chainKeystroke{
		value: slice,
		
	}
}

func (c *chainKeystroke) Value() []Keystroke {
	return c.value
}

func ConcatKeystroke(slice []Keystroke, slice2 []Keystroke) (res []Keystroke) {
	res = make([]Keystroke, 0, len(slice) + len(slice2))
	for _, entry := range slice {
		res = append(res, entry)
	}
	for _, entry := range slice2 {
		res = append(res, entry)
	}
	return
}

func (c *chainKeystroke) Concat(slice2 []Keystroke) *chainKeystroke {
	return &chainKeystroke{value: ConcatKeystroke(c.value, slice2)}
}

func DropKeystroke(slice []Keystroke, n int) (res []Keystroke) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]Keystroke, 0, l)
	for _, entry := range slice[len(slice) - l:] {
		res = append(res, entry)
	}
	return
}

func (c *chainKeystroke) Drop(n int) *chainKeystroke {
	return &chainKeystroke{value: DropKeystroke(c.value, n)}
}

func DropRightKeystroke(slice []Keystroke, n int) (res []Keystroke) {
	l := len(slice) - n
	if l < 0 {
		l = 0
	}
	res = make([]Keystroke, 0, l)
	for _, entry := range slice[:l] {
		res = append(res, entry)
	}
	return
}

func (c *chainKeystroke) DropRight(n int) *chainKeystroke {
	return &chainKeystroke{value: DropRightKeystroke(c.value, n)}
}

func FilterKeystroke(slice []Keystroke, fn func(Keystroke,int)bool) (res []Keystroke) {
	res = make([]Keystroke, 0, len(slice))
	for index, entry := range slice {
		if fn(entry, index) {
			res = append(res, entry)
		}
	}
	return
}

func (c *chainKeystroke) Filter(fn func(Keystroke,int)bool) *chainKeystroke {
	return &chainKeystroke{value: FilterKeystroke(c.value, fn)}
}

func FirstKeystroke(slice []Keystroke) (res Keystroke) {
	if len(slice) == 0 {
		return
	}
	res = slice[0]
	return
}

func (c *chainKeystroke) First() *chainKeystroke {
	return &chainKeystroke{value: []Keystroke{FirstKeystroke(c.value)}}
}

func LastKeystroke(slice []Keystroke) (res Keystroke) {
	if len(slice) == 0 {
		return
	}
	res = slice[len(slice) - 1]
	return
}

func (c *chainKeystroke) Last() *chainKeystroke {
	return &chainKeystroke{value: []Keystroke{LastKeystroke(c.value)}}
}

func MapKeystroke(slice []Keystroke, fn func(Keystroke,int)Keystroke) (res []Keystroke) {
	res = make([]Keystroke, 0, len(slice))
	for index, entry := range slice {
		res = append(res, fn(entry, index))
	}
	return
}

func (c *chainKeystroke) Map(fn func(Keystroke,int)Keystroke) *chainKeystroke {
	return &chainKeystroke{value: MapKeystroke(c.value, fn)}
}


func ReduceKeystroke(slice []Keystroke, fn func(Keystroke,Keystroke,int)Keystroke, initial Keystroke) (res Keystroke) {
	res = initial
	for index, entry := range slice {
		res = fn(res, entry, index)
	}
	return
}

func (c *chainKeystroke) Reduce(fn func(Keystroke,Keystroke,int)Keystroke, initial Keystroke) *chainKeystroke {
	return &chainKeystroke{value: []Keystroke{ReduceKeystroke(c.value, fn, initial)}}
}

func ReverseKeystroke(slice []Keystroke) (res []Keystroke) {
	res = make([]Keystroke, len(slice))
	for index, entry := range slice {
		res[len(slice)-1-index] = entry
	}
	return
}

func (c *chainKeystroke) Reverse() *chainKeystroke {
	return &chainKeystroke{value: ReverseKeystroke(c.value)}
}

func UniqKeystroke(slice []Keystroke) (res []Keystroke) {
	seen := make(map[Keystroke]bool)
	res = []Keystroke{}
	for _, entry := range slice {
		if _, found := seen[entry]; !found {
			seen[entry] = true
			res = append(res, entry)
		}
	}
	return
}

func (c *chainKeystroke) Uniq() *chainKeystroke {
	if c.isPtr {
		panic("Uniq() does not currently support pointers")
	}
	return &chainKeystroke{value: UniqKeystroke(c.value)}
}
